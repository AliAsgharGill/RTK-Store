import{coreModule as Ue,buildCreateApi as Pe}from"@reduxjs/toolkit/query";import"@reduxjs/toolkit";import{formatProdErrorMessage as fe}from"@reduxjs/toolkit";import"@reduxjs/toolkit";import{createSelector as $}from"@reduxjs/toolkit";import{useCallback as q,useDebugValue as X,useEffect as P,useLayoutEffect as le,useMemo as A,useRef as U,useState as ee}from"react";import{QueryStatus as Qe,skipToken as I}from"@reduxjs/toolkit/query";import{shallowEqual as te}from"react-redux";import{useEffect as ue,useRef as ye,useMemo as pe}from"react";function j(e,i,R,m){let u=pe(()=>({queryArgs:e,serialized:typeof e=="object"?i({queryArgs:e,endpointDefinition:R,endpointName:m}):e}),[e,i,R,m]),h=ye(u);return ue(()=>{h.current.serialized!==u.serialized&&(h.current=u)},[u]),h.current.serialized===u.serialized?h.current.queryArgs:e}var L=Symbol();import{useEffect as de,useRef as ce}from"react";import{shallowEqual as Z}from"react-redux";function z(e){let i=ce(e);return de(()=>{Z(i.current,e)||(i.current=e)},[e]),Z(i.current,e)?i.current:e}import{createAction as qe,createSlice as Ie,createSelector as Ce,createAsyncThunk as Ke,combineReducers as Ve,createNextState as _e,isAnyOf as je,isAllOf as We,isAction as $e,isPending as Ge,isRejected as Ze,isFulfilled as Je,isRejectedWithValue as Ye,isAsyncThunkAction as Xe,prepareAutoBatched as et,SHOULD_AUTOBATCH as tt,isPlainObject as W,nanoid as nt}from"@reduxjs/toolkit";var J=WeakMap?new WeakMap:void 0,Y=({endpointName:e,queryArgs:i})=>{let R="",m=J?.get(i);if(typeof m=="string")R=m;else{let u=JSON.stringify(i,(h,S)=>W(S)?Object.keys(S).sort().reduce((B,k)=>(B[k]=S[k],B),{}):S);W(i)&&J?.set(i,u),R=u}return`${e}(${R})`};var Te=typeof window<"u"&&window.document&&window.document.createElement?le:P,ge=e=>e.isUninitialized?{...e,isUninitialized:!1,isFetching:!0,isLoading:e.data===void 0,status:Qe.pending}:e;function ne({api:e,moduleOptions:{batch:i,hooks:{useDispatch:R,useSelector:m,useStore:u},unstable__sideEffectsInRender:h},serializeQueryArgs:S,context:B}){let k=h?t=>t():P;return{buildQueryHooks:b,buildMutationHook:v,usePrefetch:V};function K(t,c,p){if(c?.endpointName&&t.isUninitialized){let{endpointName:a}=c,y=B.endpointDefinitions[a];S({queryArgs:c.originalArgs,endpointDefinition:y,endpointName:a})===S({queryArgs:p,endpointDefinition:y,endpointName:a})&&(c=void 0)}let f=t.isSuccess?t.data:c?.data;f===void 0&&(f=t.data);let s=f!==void 0,r=t.isLoading,n=!s&&r,o=t.isSuccess||r&&s;return{...t,data:f,currentData:t.data,isFetching:r,isLoading:n,isSuccess:o}}function V(t,c){let p=R(),f=z(c);return q((s,r)=>p(e.util.prefetch(t,s,{...f,...r})),[t,p,f])}function b(t){let c=(s,{refetchOnReconnect:r,refetchOnFocus:n,refetchOnMountOrArgChange:o,skip:a=!1,pollingInterval:y=0}={})=>{let{initiate:T}=e.endpoints[t],l=R(),d=U();if(!d.current){let E=l(e.internalActions.internal_getRTKQSubscriptions());d.current=E}let D=j(a?I:s,Y,B.endpointDefinitions[t],t),g=z({refetchOnReconnect:r,refetchOnFocus:n,pollingInterval:y}),x=U(!1),Q=U(),{queryCacheKey:M,requestId:w}=Q.current||{},O=!1;M&&w&&(O=d.current.isRequestSubscribed(M,w));let N=!O&&x.current;return k(()=>{x.current=O}),k(()=>{N&&(Q.current=void 0)},[N]),k(()=>{let E=Q.current;if(typeof process<"u",D===I){E?.unsubscribe(),Q.current=void 0;return}let H=Q.current?.subscriptionOptions;if(!E||E.arg!==D){E?.unsubscribe();let _=l(T(D,{subscriptionOptions:g,forceRefetch:o}));Q.current=_}else g!==H&&E.updateSubscriptionOptions(g)},[l,T,o,D,g,N]),P(()=>()=>{Q.current?.unsubscribe(),Q.current=void 0},[]),A(()=>({refetch:()=>{if(!Q.current)throw new Error(fe(38));return Q.current?.refetch()}}),[])},p=({refetchOnReconnect:s,refetchOnFocus:r,pollingInterval:n=0}={})=>{let{initiate:o}=e.endpoints[t],a=R(),[y,T]=ee(L),l=U(),d=z({refetchOnReconnect:s,refetchOnFocus:r,pollingInterval:n});k(()=>{let x=l.current?.subscriptionOptions;d!==x&&l.current?.updateSubscriptionOptions(d)},[d]);let D=U(d);k(()=>{D.current=d},[d]);let g=q(function(x,Q=!1){let M;return i(()=>{l.current?.unsubscribe(),l.current=M=a(o(x,{subscriptionOptions:D.current,forceRefetch:!Q})),T(x)}),M},[a,o]);return P(()=>()=>{l?.current?.unsubscribe()},[]),P(()=>{y!==L&&!l.current&&g(y,!0)},[y,g]),A(()=>[g,y],[g,y])},f=(s,{skip:r=!1,selectFromResult:n}={})=>{let{select:o}=e.endpoints[t],a=j(r?I:s,S,B.endpointDefinitions[t],t),y=U(),T=A(()=>$([o(a),(x,Q)=>Q,x=>a],K),[o,a]),l=A(()=>n?$([T],n,{devModeChecks:{identityFunctionCheck:"never"}}):T,[T,n]),d=m(x=>l(x,y.current),te),D=u(),g=T(D.getState(),y.current);return Te(()=>{y.current=g},[g]),d};return{useQueryState:f,useQuerySubscription:c,useLazyQuerySubscription:p,useLazyQuery(s){let[r,n]=p(s),o=f(n,{...s,skip:n===L}),a=A(()=>({lastArg:n}),[n]);return A(()=>[r,o,a],[r,o,a])},useQuery(s,r){let n=c(s,r),o=f(s,{selectFromResult:s===I||r?.skip?void 0:ge,...r}),{data:a,status:y,isLoading:T,isSuccess:l,isError:d,error:D}=o;return X({data:a,status:y,isLoading:T,isSuccess:l,isError:d,error:D}),A(()=>({...o,...n}),[o,n])}}}function v(t){return({selectFromResult:c,fixedCacheKey:p}={})=>{let{select:f,initiate:s}=e.endpoints[t],r=R(),[n,o]=ee();P(()=>()=>{n?.arg.fixedCacheKey||n?.reset()},[n]);let a=q(function(_){let G=r(s(_,{fixedCacheKey:p}));return o(G),G},[r,s,p]),{requestId:y}=n||{},T=A(()=>f({fixedCacheKey:p,requestId:n?.requestId}),[p,n,f]),l=A(()=>c?$([T],c):T,[c,T]),d=m(l,te),D=p==null?n?.arg.originalArgs:void 0,g=q(()=>{i(()=>{n&&o(void 0),p&&r(e.internalActions.removeMutationResult({requestId:y,fixedCacheKey:p}))})},[r,p,n,y]),{endpointName:x,data:Q,status:M,isLoading:w,isSuccess:O,isError:N,error:E}=d;X({endpointName:x,data:Q,status:M,isLoading:w,isSuccess:O,isError:N,error:E});let H=A(()=>({...d,originalArgs:D,reset:g}),[d,D,g]);return A(()=>[a,H],[a,H])}}}function re(e){return e.type==="query"}function ie(e){return e.type==="mutation"}function C(e){return e.replace(e[0],e[0].toUpperCase())}function F(e,...i){return Object.assign(e,...i)}import{useDispatch as Re,useSelector as De,useStore as me,batch as xe}from"react-redux";var se=Symbol(),oe=({batch:e=xe,hooks:i={useDispatch:Re,useSelector:De,useStore:me},unstable__sideEffectsInRender:R=!1,...m}={})=>({name:se,init(u,{serializeQueryArgs:h},S){let B=u,{buildQueryHooks:k,buildMutationHook:K,usePrefetch:V}=ne({api:u,moduleOptions:{batch:e,hooks:i,unstable__sideEffectsInRender:R},serializeQueryArgs:h,context:S});return F(B,{usePrefetch:V}),F(S,{batch:e}),{injectEndpoint(b,v){if(re(v)){let{useQuery:t,useLazyQuery:c,useLazyQuerySubscription:p,useQueryState:f,useQuerySubscription:s}=k(b);F(B.endpoints[b],{useQuery:t,useLazyQuery:c,useLazyQuerySubscription:p,useQueryState:f,useQuerySubscription:s}),u[`use${C(b)}Query`]=t,u[`useLazy${C(b)}Query`]=c}else if(ie(v)){let t=K(b);F(B.endpoints[b],{useMutation:t}),u[`use${C(b)}Mutation`]=t}}}}});export*from"@reduxjs/toolkit/query";import{formatProdErrorMessage as Se}from"@reduxjs/toolkit";import{configureStore as Ae}from"@reduxjs/toolkit";import{useContext as he}from"react";import{useEffect as Be}from"react";import ae from"react";import{Provider as ke,ReactReduxContext as be}from"react-redux";import{setupListeners as Ee}from"@reduxjs/toolkit/query";function Me(e){let i=e.context||be;if(he(i))throw new Error(Se(35));let[m]=ae.useState(()=>Ae({reducer:{[e.api.reducerPath]:e.api.reducer},middleware:u=>u().concat(e.api.middleware)}));return Be(()=>e.setupListeners===!1?void 0:Ee(m.dispatch,e.setupListeners),[e.setupListeners,m.dispatch]),ae.createElement(ke,{store:m,context:i},e.children)}var Lt=Pe(Ue(),oe());export{Me as ApiProvider,Lt as createApi,oe as reactHooksModule,se as reactHooksModuleName};
//# sourceMappingURL=rtk-query-react.browser.mjs.map